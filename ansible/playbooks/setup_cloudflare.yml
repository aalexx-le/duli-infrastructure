---
# ============================================================================
# CLOUDFLARE SETUP - Tunnel + DNS + SSL
# ============================================================================
# Automated setup of Cloudflare Tunnel, DNS records, and SSL/TLS settings.
# Prerequisites: vault_cloudflare_api_token, vault_cloudflare_account_id
# ============================================================================

- name: Complete Cloudflare Setup (Tunnel + DNS + SSL)
  hosts: localhost
  connection: local
  gather_facts: true
  vars:
    cloudflare_zone: "duli.one"
    cloudflare_email: "engineer.duli@gmail.com"
    tunnel_name: "duli-tunnel"
    cloudflared_namespace: "cloudflare-system"
    helm_chart_path: "{{ playbook_dir }}/../../helm/cloudflared"
    
    # DNS subdomains for HTTPS services (via ingress-nginx)
    cloudflare_subdomains:
      - name: "@"
        type: "A"
      - name: "api"
        type: "CNAME"
        content: "duli.one"
      - name: "ai"
        type: "CNAME"
        content: "duli.one"
      - name: "n8n"
        type: "CNAME"
        content: "duli.one"
      - name: "auth"
        type: "CNAME"
        content: "duli.one"
      - name: "argocd"
        type: "CNAME"
        content: "duli.one"
      - name: "rancher"
        type: "CNAME"
        content: "duli.one"
      - name: "queue"
        type: "CNAME"
        content: "duli.one"
      - name: "queue.staging"
        type: "CNAME"
        content: "duli.one"

  tasks:
    # ========================================================================
    # CLOUDFLARE TUNNEL
    # ========================================================================
    
    - name: Validate Cloudflare credentials
      assert:
        that:
          - vault_cloudflare_api_token is defined
          - vault_cloudflare_api_token | length > 0
          - vault_cloudflare_api_token != "change-me-to-your-cloudflare-api-token"
          - vault_cloudflare_account_id is defined
          - vault_cloudflare_account_id | length > 0
          - vault_cloudflare_account_id != "change-me-to-your-cloudflare-account-id"
        fail_msg: "Cloudflare API token and Account ID must be set in vault.yml"
    
    - name: Check if cloudflared CLI is installed
      command: which cloudflared
      register: cloudflared_check
      failed_when: false
      changed_when: false
    
    - name: Display cloudflared installation instructions if missing
      fail:
        msg: |
          Install cloudflared CLI:
          macOS: brew install cloudflare/cloudflare/cloudflared
          Linux: wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb && sudo dpkg -i cloudflared-linux-amd64.deb
      when: cloudflared_check.rc != 0
    
    - name: Check if Cloudflare cert exists
      stat:
        path: "{{ ansible_env.HOME }}/.cloudflared/cert.pem"
      register: cloudflare_cert
    
    - name: Authenticate with Cloudflare if needed
      fail:
        msg: "Run: cloudflared tunnel login"
      when: not cloudflare_cert.stat.exists
    
    - name: List existing tunnels
      command: cloudflared tunnel list --output json
      register: tunnel_list
      changed_when: false
    
    - name: Parse tunnel list
      set_fact:
        existing_tunnels: "{{ tunnel_list.stdout | from_json }}"
        tunnel_exists: "{{ tunnel_list.stdout | from_json | selectattr('name', 'equalto', tunnel_name) | list | length > 0 }}"
    
    - name: Get existing tunnel ID
      set_fact:
        tunnel_id: "{{ (existing_tunnels | selectattr('name', 'equalto', tunnel_name) | first).id }}"
      when: tunnel_exists
    
    - name: Create new Cloudflare Tunnel
      command: "cloudflared tunnel --output json create {{ tunnel_name }}"
      register: tunnel_create
      when: not tunnel_exists
    
    - name: Set tunnel ID from creation
      set_fact:
        tunnel_id: "{{ (tunnel_create.stdout | from_json).id }}"
      when: not tunnel_exists
    
    - name: Find and read tunnel credentials
      block:
        - find:
            paths: "{{ ansible_env.HOME }}/.cloudflared"
            patterns: "{{ tunnel_id }}.json"
          register: tunnel_creds_file
        
        - name: Check if credentials file exists
          fail:
            msg: |
              Tunnel credentials file not found: {{ ansible_env.HOME }}/.cloudflared/{{ tunnel_id }}.json
              
              This usually happens when:
              1. The tunnel was created on a different machine
              2. The credentials file was deleted
              
              Solutions:
              1. Delete the existing tunnel and let Ansible create a new one:
                 cloudflared tunnel delete {{ tunnel_name }}
              
              2. Or manually download the credentials from Cloudflare dashboard
          when: tunnel_creds_file.files | length == 0
        
        - slurp:
            src: "{{ tunnel_creds_file.files[0].path }}"
          register: tunnel_creds_content
          when: tunnel_creds_file.files | length > 0
        
        - set_fact:
            tunnel_credentials: "{{ tunnel_creds_content.content | b64decode | from_json }}"
            tunnel_creds_base64: "{{ tunnel_creds_content.content }}"
          when: tunnel_creds_file.files | length > 0
    
    - name: Create cloudflare-system namespace
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ cloudflared_namespace }}"
    
    - name: Create tunnel credentials secret
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: cloudflared-credentials
            namespace: "{{ cloudflared_namespace }}"
          type: Opaque
          data:
            credentials.json: "{{ tunnel_creds_base64 }}"
    
    - name: Deploy cloudflared via Helm
      kubernetes.core.helm:
        name: cloudflared
        chart_ref: "{{ helm_chart_path }}"
        release_namespace: "{{ cloudflared_namespace }}"
        create_namespace: true
        values:
          cloudflare:
            account: "{{ vault_cloudflare_account_id }}"
            tunnelName: "{{ tunnel_name }}"
            tunnelId: "{{ tunnel_id }}"
            secretName: cloudflared-credentials
            enableWarp: true
            edgeIPVersion: "4"
            ingress:
              - hostname: db.staging.duli.one
                service: tcp://database-rw.staging.svc.cluster.local:5432
              - hostname: redis.staging.duli.one
                service: tcp://redis-replication.staging.svc.cluster.local:6379
              - hostname: mq.staging.duli.one
                service: tcp://queue.staging.svc.cluster.local:5672
              - hostname: db.duli.one
                service: tcp://database-rw.prod.svc.cluster.local:5432
              - hostname: redis.duli.one
                service: tcp://redis-replication.prod.svc.cluster.local:6379
              - hostname: mq.duli.one
                service: tcp://queue.prod.svc.cluster.local:5672
              - hostname: argocd-staging.duli.one
                service: http://ingress-nginx-controller.ingress-nginx.svc.cluster.local:80
              - hostname: rancher-staging.duli.one
                service: http://ingress-nginx-controller.ingress-nginx.svc.cluster.local:80
              - hostname: queue-staging.duli.one
                service: http://ingress-nginx-controller.ingress-nginx.svc.cluster.local:80
              - hostname: argocd.duli.one
                service: http://ingress-nginx-controller.ingress-nginx.svc.cluster.local:80
              - hostname: rancher.duli.one
                service: http://ingress-nginx-controller.ingress-nginx.svc.cluster.local:80
              - hostname: queue.duli.one
                service: http://ingress-nginx-controller.ingress-nginx.svc.cluster.local:80
              # Note: Catch-all (http_status:404) is auto-added by Helm template
          replicaCount: 2
          image:
            tag: "2024.12.2"
        wait: true
        wait_timeout: 5m
    
    - name: Wait for cloudflared pods
      kubernetes.core.k8s_info:
        kind: Pod
        namespace: "{{ cloudflared_namespace }}"
        label_selectors:
          - app.kubernetes.io/name=cloudflare-tunnel
      register: cloudflared_pods
      until: >
        cloudflared_pods.resources | length > 0 and
        cloudflared_pods.resources | selectattr('status.phase', 'equalto', 'Running') | list | length == cloudflared_pods.resources | length
      retries: 30
      delay: 10
    
    # ========================================================================
    # DNS AND SSL
    # ========================================================================
    
    - name: Get ingress-nginx LoadBalancer IP
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Service
        name: ingress-nginx
        namespace: ingress-nginx
      register: ingress_service
      until: >
        ingress_service.resources | length > 0 and
        ingress_service.resources[0].status.loadBalancer.ingress is defined and
        ingress_service.resources[0].status.loadBalancer.ingress | length > 0
      retries: 30
      delay: 10
    
    - name: Extract LoadBalancer IP
      set_fact:
        loadbalancer_ip: "{{ ingress_service.resources[0].status.loadBalancer.ingress[0].ip }}"
    
    - name: Get Cloudflare Zone ID
      uri:
        url: "https://api.cloudflare.com/client/v4/zones?name={{ cloudflare_zone }}"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
          Content-Type: "application/json"
        status_code: [200]
      register: zone_lookup
    
    - name: Extract Zone ID
      set_fact:
        zone_id: "{{ zone_lookup.json.result[0].id }}"
    
    - name: Configure root A record
      community.general.cloudflare_dns:
        zone: "{{ cloudflare_zone }}"
        record: "{{ cloudflare_zone }}"
        type: A
        value: "{{ loadbalancer_ip }}"
        proxied: yes
        api_token: "{{ vault_cloudflare_api_token }}"
        state: present
    
    - name: Configure CNAME records
      community.general.cloudflare_dns:
        zone: "{{ cloudflare_zone }}"
        record: "{{ item.name }}.{{ cloudflare_zone if item.name != '@' else '' }}"
        type: "{{ item.type }}"
        value: "{{ item.content }}"
        proxied: yes
        api_token: "{{ vault_cloudflare_api_token }}"
        state: present
      loop: "{{ cloudflare_subdomains | selectattr('type', 'equalto', 'CNAME') | list }}"

    - name: Create Cloudflare Tunnel DNS records
      community.general.cloudflare_dns:
        zone: "{{ cloudflare_zone }}"
        record: "{{ item }}"
        type: CNAME
        value: "{{ tunnel_id }}.cfargotunnel.com"
        proxied: no  # DNS-only mode for Tunnel
        api_token: "{{ vault_cloudflare_api_token }}"
        state: present
        timeout: 60  # Increase timeout for slow API
      retries: 3
      delay: 5
      register: dns_result
      until: dns_result is succeeded
      loop:
        # TCP Services
        - "db.staging.{{ cloudflare_zone }}"
        - "redis.staging.{{ cloudflare_zone }}"
        - "mq.staging.{{ cloudflare_zone }}"
        - "db.{{ cloudflare_zone }}"
        - "redis.{{ cloudflare_zone }}"
        - "mq.{{ cloudflare_zone }}"
        # HTTPS Services (via tunnel, then ingress-nginx)
        - "argocd-staging.{{ cloudflare_zone }}"
        - "rancher-staging.{{ cloudflare_zone }}"
        - "queue-staging.{{ cloudflare_zone }}"
        - "argocd.{{ cloudflare_zone }}"
        - "rancher.{{ cloudflare_zone }}"
        - "queue.{{ cloudflare_zone }}"
    
    - name: Set SSL mode to Full (Strict)
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/ssl"
        method: PATCH
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          value: "strict"
        status_code: [200]
    
    - name: Enable Always Use HTTPS
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/always_use_https"
        method: PATCH
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
        body_format: json
        body:
          value: "on"
        status_code: [200]
    
    - name: Set Minimum TLS Version to 1.2
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/min_tls_version"
        method: PATCH
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
        body_format: json
        body:
          value: "1.2"
        status_code: [200]
    
    - name: Enable TLS 1.3
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/tls_1_3"
        method: PATCH
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
        body_format: json
        body:
          value: "on"
        status_code: [200]
    
    - name: Enable Automatic HTTPS Rewrites
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/automatic_https_rewrites"
        method: PATCH
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
        body_format: json
        body:
          value: "on"
        status_code: [200]
    
    # ========================================================================
    # CLOUDFLARE ACCESS - Zero Trust Applications
    # ========================================================================
    
    - name: Validate Cloudflare Access configuration
      assert:
        that:
          - cloudflare_access_allowed_emails is defined
          - cloudflare_access_allowed_emails | length > 0
        fail_msg: |
          Cloudflare Access email configuration missing in cloudflare.yml
          Add: cloudflare_access_allowed_emails: ["user@example.com", "@yourdomain.com"]
    
    - name: Get Cloudflare Zone ID for Access
      set_fact:
        access_zone_id: "{{ zone_id }}"
    
    - name: Define TCP infrastructure services for Access
      set_fact:
        tcp_services:
          - name: "PostgreSQL Staging"
            domain: "db.staging.{{ cloudflare_zone }}"
            description: "Staging PostgreSQL database - TCP port 5432"
          - name: "Redis Staging"
            domain: "redis.staging.{{ cloudflare_zone }}"
            description: "Staging Redis cache - TCP port 6379"
          - name: "RabbitMQ Staging"
            domain: "mq.staging.{{ cloudflare_zone }}"
            description: "Staging RabbitMQ AMQP - TCP port 5672"
          - name: "PostgreSQL Production"
            domain: "db.{{ cloudflare_zone }}"
            description: "Production PostgreSQL database - TCP port 5432"
          - name: "Redis Production"
            domain: "redis.{{ cloudflare_zone }}"
            description: "Production Redis cache - TCP port 6379"
          - name: "RabbitMQ Production"
            domain: "mq.{{ cloudflare_zone }}"
            description: "Production RabbitMQ AMQP - TCP port 5672"
    
    - name: Create Cloudflare Access Applications for TCP services
      uri:
        url: "https://api.cloudflare.com/client/v4/accounts/{{ vault_cloudflare_account_id }}/access/apps"
        method: POST
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "{{ item.name }}"
          domain: "{{ item.domain }}"
          type: "self_hosted"
          session_duration: "24h"
          allowed_idps: []
          auto_redirect_to_identity: false
          enable_binding_cookie: false
          custom_deny_message: "Access denied. Please contact your administrator."
          custom_deny_url: ""
          logo_url: ""
          skip_interstitial: false
          app_launcher_visible: true
          service_auth_401_redirect: true
          cors_headers:
            allowed_methods:
              - GET
              - POST
              - OPTIONS
            allowed_origins:
              - "*"
            allow_credentials: true
            max_age: 86400
        status_code: [200, 201, 409]  # 409 = already exists
      register: access_app_result
      loop: "{{ tcp_services }}"
      loop_control:
        label: "{{ item.name }}"
      failed_when: 
        - access_app_result.status not in [200, 201, 409]
        - access_app_result.status != 403
      ignore_errors: true
    
    - name: Check for permission errors
      fail:
        msg: |
          ❌ Cloudflare API token lacks permissions to create Access applications.
          
          Required permissions (create new token at https://dash.cloudflare.com/profile/api-tokens):
            - Account - Cloudflare Tunnel - Edit
            - Account - Access: Apps and Policies - Edit
            - Zone - Zone - Read
            - Zone - DNS - Edit
            - Zone - Zone Settings - Edit
          
          Account Resources: Include - All accounts
          Zone Resources: Include - Specific zone - duli.one
          
          After creating the token, update vault.yml:
            ansible-vault edit inventories/group_vars/all/vault.yml
      when: access_app_result.results | selectattr('status', 'equalto', 403) | list | length > 0
    
    - name: Get existing Access Applications to extract IDs
      uri:
        url: "https://api.cloudflare.com/client/v4/accounts/{{ vault_cloudflare_account_id }}/access/apps"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
          Content-Type: "application/json"
        status_code: [200]
      register: existing_access_apps
    
    - name: Map application names to IDs
      set_fact:
        access_app_ids: "{{ access_app_ids | default({}) | combine({item.name: item.id}) }}"
      loop: "{{ existing_access_apps.json.result }}"
      when: item.domain in tcp_services | map(attribute='domain') | list
      loop_control:
        label: "{{ item.name }}"
    
    - name: Build Access policy include rules
      set_fact:
        access_policy_include: "{{ access_policy_include | default([]) + [{'email': {'email': item}}] }}"
      loop: "{{ cloudflare_access_allowed_emails | select('match', '^[^@]+@') | list }}"
      when: not item.startswith('@')
    
    - name: Add domain-based rules to Access policy
      set_fact:
        access_policy_include: "{{ access_policy_include | default([]) + [{'email_domain': {'domain': item | regex_replace('^@', '')}}] }}"
      loop: "{{ cloudflare_access_allowed_emails | select('match', '^@') | list }}"
    
    - name: Create Access Policies for TCP services
      uri:
        url: "https://api.cloudflare.com/client/v4/accounts/{{ vault_cloudflare_account_id }}/access/apps/{{ access_app_ids[item.name] }}/policies"
        method: POST
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "Allow Authorized Developers"
          decision: "allow"
          precedence: 1
          include: "{{ access_policy_include }}"
          exclude: []
          require: []
          session_duration: "24h"
        status_code: [200, 201, 409]
      register: access_policy_result
      loop: "{{ tcp_services }}"
      when: access_app_ids[item.name] is defined
      loop_control:
        label: "{{ item.name }}"
    
    - name: Display Cloudflare Access summary
      debug:
        msg: |
          ✓ Cloudflare Access Applications created
          ✓ Policies configured for: {{ cloudflare_access_allowed_emails | join(', ') }}
          
          Access Dashboard: https://one.dash.cloudflare.com/{{ vault_cloudflare_account_id }}/access/apps
          
          Developers can now connect directly:
          - psql -h db.staging.duli.one -p 5432 -U duli_user
          - redis-cli -h redis.staging.duli.one -p 6379
          - amqp://mq.staging.duli.one:5672
          
          First-time authentication required via browser or WARP client
    
    # ========================================================================
    # DEPLOYMENT SUMMARY
    # ========================================================================
    
    - name: Display deployment summary
      debug:
        msg: |
          ✓ Tunnel: {{ tunnel_name }} ({{ tunnel_id }})
          ✓ Replicas: {{ cloudflared_pods.resources | length }}
          ✓ LoadBalancer: {{ loadbalancer_ip }}
          ✓ SSL: Full (Strict), TLS 1.2+
          ✓ Cloudflare Access: Enabled
          ✓ IPv4 Preference: Enabled (edge-ip-version=4)

          TCP Services (via Cloudflare Tunnel + Access):
            - psql -h db.staging.duli.one -p 5432
            - redis-cli -h redis.staging.duli.one -p 6379
            - amqp://mq.staging.duli.one:5672
            - psql -h db.duli.one -p 5432 (production)
            - redis-cli -h redis.duli.one -p 6379 (production)
            - amqp://mq.duli.one:5672 (production)

          HTTPS Services (via Cloudflare Tunnel + Ingress-Nginx):
            Staging:
            - https://argocd-staging.duli.one (ArgoCD)
            - https://rancher-staging.duli.one (Rancher)
            - https://queue-staging.duli.one (RabbitMQ)

            Production:
            - https://argocd.duli.one (ArgoCD)
            - https://rancher.duli.one (Rancher)
            - https://queue.duli.one (RabbitMQ)

          Next Steps:
            1. Authenticate via browser on first connection
            2. Install WARP client for better experience
            3. View access logs: https://one.dash.cloudflare.com
            4. Update WARP split tunnel policy to allow tunnel traffic
