---
# ============================================================================
# DNS AND SSL CONFIGURATION PLAYBOOK
# ============================================================================
# Configures DNS records and SSL/TLS settings for external access to services.
#
# Purpose: Configure DNS records for EXTERNAL access to Kubernetes services.
# Applications inside cluster use internal ClusterIP service names.
#
# Usage:
#   ansible-playbook -i inventories/hosts.ini playbooks/setup_dns.yml -e target_environment=staging
#   ansible-playbook -i inventories/hosts.ini playbooks/setup_dns.yml -e target_environment=prod
# ============================================================================

- name: Configure DNS and SSL for external access to Kubernetes services
  hosts: localhost
  connection: local
  gather_facts: true
  vars:
    cloudflare_zone: "duli.one"
    
    # Shared infrastructure subdomains
    shared_subdomains:
      - name: "argocd"
        type: "A"
        proxied: yes
      - name: "grafana"
        type: "A"
        proxied: yes
    
    # Environment-specific HTTP services
    env_configs:
      staging:
        subdomains:
          - name: "api-staging"
            type: "A"
            proxied: yes
          - name: "ai-staging"
            type: "A"
            proxied: yes
          - name: "n8n-staging"
            type: "A"
            proxied: yes
          - name: "auth-staging"
            type: "A"
            proxied: yes
          - name: "queue-staging"
            type: "A"
            proxied: yes
        tcp_services:
          - name: "db-staging"
            port: 5432
            description: "PostgreSQL - External access"
          - name: "redis-staging"
            port: 6379
            description: "Redis - External access"
          - name: "mq-staging"
            port: 5672
            description: "RabbitMQ - External access"
      prod:
        subdomains:
          - name: "api"
            type: "A"
            proxied: yes
          - name: "ai"
            type: "A"
            proxied: yes
          - name: "n8n"
            type: "A"
            proxied: yes
          - name: "auth"
            type: "A"
            proxied: yes
          - name: "queue"
            type: "A"
            proxied: yes
        tcp_services:
          - name: "db"
            port: 5433
            description: "PostgreSQL - External access"
          - name: "redis"
            port: 6380
            description: "Redis - External access"
          - name: "mq"
            port: 5673
            description: "RabbitMQ - External access"

  tasks:
    - name: Validate target_environment
      assert:
        that:
          - target_environment is defined
          - target_environment in ['staging', 'prod']
        fail_msg: "Use: -e target_environment=staging or -e target_environment=prod"

    - name: Set environment config
      set_fact:
        env_config: "{{ env_configs[target_environment] }}"

    - name: Get ingress-nginx LoadBalancer IP
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Service
        name: ingress-nginx
        namespace: ingress-nginx
      register: ingress_service
      until: >
        ingress_service.resources | length > 0 and
        ingress_service.resources[0].status.loadBalancer.ingress is defined
      retries: 30
      delay: 10
    
    - name: Extract LoadBalancer IP
      set_fact:
        loadbalancer_ip: "{{ ingress_service.resources[0].status.loadBalancer.ingress[0].ip }}"
    
    - name: Get Cloudflare Zone ID
      uri:
        url: "https://api.cloudflare.com/client/v4/zones?name={{ cloudflare_zone }}"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
        status_code: [200]
      register: zone_lookup
    
    - name: Extract Zone ID
      set_fact:
        zone_id: "{{ zone_lookup.json.result[0].id }}"
    
    - name: Configure root A record
      community.general.cloudflare_dns:
        zone: "{{ cloudflare_zone }}"
        record: "{{ cloudflare_zone }}"
        type: A
        value: "{{ loadbalancer_ip }}"
        proxied: yes
        api_token: "{{ vault_cloudflare_api_token }}"
        state: present
        solo: true  # Remove duplicate A records, keep only this one
      when: target_environment == 'prod'
    
    - name: Configure shared infrastructure A records
      community.general.cloudflare_dns:
        zone: "{{ cloudflare_zone }}"
        record: "{{ item.name }}.{{ cloudflare_zone }}"
        type: A
        value: "{{ loadbalancer_ip }}"
        proxied: "{{ item.proxied }}"
        api_token: "{{ vault_cloudflare_api_token }}"
        state: present
        solo: true  # Remove duplicate A records, keep only this one
      loop: "{{ shared_subdomains }}"

    - name: Delete old CNAME records for HTTP services
      community.general.cloudflare_dns:
        zone: "{{ cloudflare_zone }}"
        record: "{{ item.name }}.{{ cloudflare_zone }}"
        type: CNAME
        api_token: "{{ vault_cloudflare_api_token }}"
        state: absent
      loop: "{{ env_config.subdomains }}"
      ignore_errors: true

    - name: Configure HTTP service A records
      community.general.cloudflare_dns:
        zone: "{{ cloudflare_zone }}"
        record: "{{ item.name }}.{{ cloudflare_zone }}"
        type: A
        value: "{{ loadbalancer_ip }}"
        proxied: "{{ item.proxied }}"
        api_token: "{{ vault_cloudflare_api_token }}"
        state: present
        solo: true  # Remove duplicate A records, keep only this one
      loop: "{{ env_config.subdomains }}"
    
    - name: Delete old Cloudflare Tunnel CNAME records for TCP services
      community.general.cloudflare_dns:
        zone: "{{ cloudflare_zone }}"
        record: "{{ item.name }}.{{ cloudflare_zone }}"
        type: CNAME
        api_token: "{{ vault_cloudflare_api_token }}"
        state: absent
      loop: "{{ env_config.tcp_services }}"
    
    - name: Configure TCP service A records (unproxied - for external access)
      community.general.cloudflare_dns:
        zone: "{{ cloudflare_zone }}"
        record: "{{ item.name }}.{{ cloudflare_zone }}"
        type: A
        value: "{{ loadbalancer_ip }}"
        proxied: no
        api_token: "{{ vault_cloudflare_api_token }}"
        state: present
        solo: true  # Remove duplicate A records, keep only this one
      loop: "{{ env_config.tcp_services }}"
    
    - name: Set SSL mode to Full (Strict)
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/ssl"
        method: PATCH
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          value: "strict"
        status_code: [200]
    
    - name: Enable Always Use HTTPS
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/always_use_https"
        method: PATCH
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
        body_format: json
        body:
          value: "on"
        status_code: [200]
    
    - name: Set Minimum TLS Version to 1.2
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/min_tls_version"
        method: PATCH
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
        body_format: json
        body:
          value: "1.2"
        status_code: [200]
    
    - name: Enable TLS 1.3
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/tls_1_3"
        method: PATCH
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
        body_format: json
        body:
          value: "on"
        status_code: [200]
    
    - name: Enable Automatic HTTPS Rewrites
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/automatic_https_rewrites"
        method: PATCH
        headers:
          Authorization: "Bearer {{ vault_cloudflare_api_token }}"
        body_format: json
        body:
          value: "on"
        status_code: [200]
    
    - name: Display summary
      debug:
        msg: |
          DNS Configuration Complete
          Environment: {{ target_environment }}
          LoadBalancer: {{ loadbalancer_ip }}
          
          HTTP Services (Cloudflare proxied):
          {% for item in env_config.subdomains %}
            - {{ item.name }}.{{ cloudflare_zone }}
          {% endfor %}
          
          TCP Services (Direct, unproxied - for EXTERNAL access only):
          {% for item in env_config.tcp_services %}
            - {{ item.name }}.{{ cloudflare_zone }}:{{ item.port }} - {{ item.description }}
          {% endfor %}
          
          NOTE: Applications inside cluster continue using internal service names:
            - database-rw.{{ target_environment }}.svc.cluster.local
            - redis-replication-master.{{ target_environment }}.svc.cluster.local
            - queue.{{ target_environment }}.svc.cluster.local

